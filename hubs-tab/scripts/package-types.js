#!/usr/bin/env node
/**
 * Package Module Federation types for CDN distribution
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const TYPES_DIR = path.join(__dirname, '../dist/types');
const OUTPUT_DIR = path.join(__dirname, '../dist/@mf-types');
const OUTPUT_ZIP = path.join(__dirname, '../dist/@mf-types.zip');

// Module Federation exposes configuration
const EXPOSES = {
  './Plugin': './src/plugin',
};

function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function getTypeFilePath(sourcePath) {
  // Convert './src/plugin' to 'plugin.d.ts'
  const relativePath = sourcePath.replace('./src/', '');
  const directPath = path.join(TYPES_DIR, `${relativePath}.d.ts`);

  if (fs.existsSync(directPath)) {
    return directPath;
  }
  return null;
}

function getModuleName(exposeName) {
  return `hubs_tab${exposeName.replace('./', '/')}`;
}

function createModuleDeclaration(exposeName, sourcePath) {
  const typeFile = getTypeFilePath(sourcePath);

  if (!typeFile) {
    console.warn(`⚠️  Type file not found for: ${sourcePath}`);
    return null;
  }

  const typeContent = fs.readFileSync(typeFile, 'utf-8');
  const moduleName = getModuleName(exposeName);

  return `declare module '${moduleName}' {\n${typeContent}\n}\n`;
}

function main() {
  console.log('📦 Packaging Module Federation types for hubs-tab...\n');

  if (!fs.existsSync(TYPES_DIR)) {
    console.log('⚠️  No types generated yet. Run: npx tsc --emitDeclarationOnly --declaration --declarationDir dist/types');
    return;
  }

  // Clean output directory
  if (fs.existsSync(OUTPUT_DIR)) {
    fs.rmSync(OUTPUT_DIR, { recursive: true });
  }
  ensureDir(OUTPUT_DIR);

  let indexContent = '// Module Federation Type Declarations\n';
  indexContent += '// Generated by package-types.js\n\n';

  let successCount = 0;
  let failCount = 0;

  Object.entries(EXPOSES).forEach(([exposeName, sourcePath]) => {
    const declaration = createModuleDeclaration(exposeName, sourcePath);
    if (declaration) {
      indexContent += declaration + '\n';
      successCount++;
      console.log(`✅ ${getModuleName(exposeName)}`);
    } else {
      failCount++;
      console.log(`❌ ${getModuleName(exposeName)} (type file not found)`);
    }
  });

  if (successCount === 0) {
    console.log('\n⚠️  No types packaged. Build may need types to be generated first.');
    return;
  }

  const indexFile = path.join(OUTPUT_DIR, 'index.d.ts');
  fs.writeFileSync(indexFile, indexContent, 'utf-8');
  console.log(`\n📝 Created: ${indexFile}`);

  console.log('\n📦 Creating zip archive...');
  try {
    process.chdir(path.join(__dirname, '../dist'));
    execSync(`zip -r @mf-types.zip @mf-types`, { stdio: 'inherit' });
    console.log(`✅ Created: ${OUTPUT_ZIP}`);
  } catch (error) {
    console.error('❌ Failed to create zip:', error.message);
    process.exit(1);
  }

  console.log('\n📊 Summary:');
  console.log(`   ✅ ${successCount} modules packaged`);
  console.log(`   ❌ ${failCount} modules failed`);
  console.log(`\n✨ Types ready for CDN deployment!`);
}

main();
